PREFIX mydata: <http://example.com/resource/>
PREFIX obo: <http://purl.obolibrary.org/obo/>
PREFIX rxnorm: <http://purl.bioontology.org/ontology/RXNORM/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
select 
distinct ?order_id ?source_full_name
where {
    # value or values come from upstream input, like user-requested Solr search
    values ?rxning {
        rxnorm:4917 
    }
    # the next two constraints can be applied in the SPARQL query, or could be ensured by some upstream logic
    values ?rxemployment {
        <http://example.com/resource/rxn_tty/IN>
    }
    graph mydata:employment {
        ?rxning mydata:employment ?rxemployment .
    }
    values ?source_definer {
        rxnorm:
    }
    graph mydata:defined_in {
        ?rxning mydata:defined_in ?source_definer .
    }
    # this is the "away from ingredient" RxNorm predicate whitelist
    graph rxnorm: {
        ?rxning  (rxnorm:constitutes|rxnorm:contained_in|rxnorm:has_dose_form|rxnorm:has_doseformgroup|rxnorm:has_form|rxnorm:has_tradename|rxnorm:ingredient_of|rxnorm:ingredients_of|rxnorm:isa|rxnorm:part_of|rxnorm:precise_ingredient_of|rxnorm:quantified_form_of|rxnorm:reformulation_of)* ?rxnprod .
    }
    # find orders for the bare ingredient or products containing the ingredient
    # probably won't find orders for a bare brand name
    {
        {
            graph mydata:elected_mapping {
                ?order mydata:elected_mapping ?rxning .
            }
        } union {
            graph mydata:elected_mapping {
                ?order mydata:elected_mapping ?rxnprod .
            }
        }
    }
    # get properties of the order
    graph mydata:reference_medications {
        ?order a obo:PDRO_0000024 ;
               mydata:source_full_name ?source_full_name .
    }
    graph mydata:source_med_id  {
        ?order skos:notation ?order_id .
    }
}
